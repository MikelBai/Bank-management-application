################
## ATM PROGRAM
################

Group Members
-------------
Meng Hsi Li
Haocong Wu
Mathew Bub
Zhijian Fan


###########################################
## PROGRAM FUNCTIONALITY AND INSTRUCTIONS
###########################################

Dependencies
------------
The program requires the following library dependencies to run:

junit:junit:4.12
org.mockito:mockito-all:1.10.19
com.google.code.gson:gson:2.8.5

Please add these to your project structure to ensure that the program compiles.


File Paths
----------
Any files generated by the program, including the save file and other program
output, will be placed in the phase2/externalFiles directory. Ensure that this
directory exists in your version of the repository.

Relative paths in the code are given with respect to the phase2 directory. E.g.,
in the code we write the path of outgoing.txt as "externalFiles/outgoing.txt",
and not "phase2/externalFiles/outgoing.txt". Please ensure that your project
recognizes these relative paths, i.e., the root directory of the project should
be the phase2 directory.


Running the Program
-------------------
When running the ATM, the program will attempt to load a save state from
externalFiles/BankData.ser. If this file does not exist or was generated with
outdated code, the program will display a warning and generate a default bank
with a single Bank Manager and no other users.

The username/password of the default Bank Manager is admin/admin. If you have
a default bank, the Bank Manager can be used to perform any further setup.

When setting up the bank for the first time, the Bank Manager should set the
bank time (see below for instructions on how to do this). If they do not, the
program will default to using the system time, and will display a warning to
this effect.


Shutting Down the Program
-------------------------
The program can be shut down safely by logging in as a bank employee and
navigating to ATM maintenance -> Shutdown ATM. Note: THE PROGRAM WILL NOT SAVE
ANY DATA IF YOU DO NOT SHUT IT DOWN IN THIS WAY. After closing, the program
will write a save state to externalFiles/BankData.ser. The day will be
incremented by 1 each time the program is shut down via the ATM maintenance
menu.


Format of deposits.txt
----------------------
deposits.txt accepts lines of the following two formats:

    cash $<AMOUNT>

    cheque $<AMOUNT> #<CHEQUE NUMBER>

For instance, a deposits.txt file of the following format:

    cash $100
    cheque $900 #12345

will cause a cash deposit of $100, followed by a cheque deposit of $900 whenever
a customer attempts to make a deposit. An example deposits.txt file is provided
in the externalFiles directory.


Bank Manager Functionality
--------------------------
The Bank Manager menu has the following options:

Bank management:
    - Set the current bank date
ATM maintenance:
    - View restock alerts from the ATM
    - Restock the ATM
    - Shutdown the ATM program
Administrator options:
    - Create a new user
    - Review requests from users to create new bank accounts
    - Review requests from users to create new financial products (mortgages & GICs)
    - Review requests from users to revert transactions
User options:
    - Change their own password


Customer Functionality
----------------------
The menu for a Customer has the following options:

Make a transaction:
    - Withdraw cash from the ATM
    - Deposit to an account from deposits.txt
    - Transfer between two of their own accounts
    - Transfer to the primary chequing account of another customer
    - Pay a bill to an external payee, outside of the program
    - Check the exchange rates between two currencies
Bank account information:
    - View information about a specific account, including transaction history
      and creation date
    - View a summary of all of their accounts
    - View a summary of their owned financial products
Make a request:
    - Request the creation of a new account
    - Request that a transaction be reverted
    - Request a new financial product
Account options:
    - Add an authorized user (a second owner) to an account
    - Set the currency of an owned Foreign Currency Account
User options:
    - Change their own password


Types of Users
--------------
There are 5 types of users, each having some combination of the functionality
listed above. They are as follows:

Bank Manager:
    Full admin permissions, including the ability to create users,
    approve requests, and revert transactions.

Bank Employee:
    Similar to the Bank Manager, but without the "Administrator options" panel.

Customer:
    Full ability to own accounts, make transactions, and make requests.

Youth:
    Similar to customer, but without the ability to make requests.

ATM Technician:
    Similar to customer, but with the addition of the "ATM maintenance" panel.

All of these types of users can be created by a bank manager. Whenever a
Customer, Youth, or ATM Technician is created, they are automatically assigned
a default chequing account, which becomes their primary account.


Types of Accounts
-----------------
The chequing, savings, credit card, and line of credit accounts exist as
described in the phase 1 specification. In addition to these, we have added
the following two account types:

Foreign Currency Account:
    An account used to store foreign currencies. Regular accounts are assumed
    to be given in CAD. Transfers to and from a Foreign Currency Account are
    are automatically converted to the appropriate currency, after retrieving
    the exchange rate from the Internet. The currency can be set by navigating
    to the Account options -> Set foreign currency menu. The currency can only
    be set once. Further attempts to set the currency will be denied.

Cashable GIC:
    A Guaranteed Interest Certificate account. This behaves similarly to a
    Savings Account, however it will only accumulate interest after $5000 has
    been deposited or transferred into it, and it will only accumulate interest
    on the initial $5000 investment. The balance cannot be reduced below $5000
    after this amount has been deposited.

All accounts have an overdraftLimit, which serves as the minimum balance (or
maximum amount of debt) that the Account can have. Chequing accounts have an
overdraftLimit of $-100, Savings Accounts have $0, Cashable GICs have $5000,
and both types of debt account have $-100,000.


Financial Products
------------------
We have also implemented a new feature called financial products, which are
products which attach themselves to a User's primary chequing account and
perform some monthly operation. These include the following:

Mortgage:
    This product will have an initial principle and a duration. Each month, it
    will withdraw an amount from the primary chequing account to pay down the
    principle and interest. There are no requirements to create a mortgage,
    only that the Bank Manager approves the request. If the customer fails to
    pay on a certain month, the amount deducted for the next month will be
    increased. As we are simulating a mortgage rather than a standard loan,
    the principle is not added to the customer's account on creation -- it is
    assumed to be going toward some kind of house outside of the program.

Non-Redeemable GIC:
    This product is essentially the opposite of a mortgage. Each month, it will
    deposit an amount into the primary chequing account corresponding to the
    initial investment plus interest. In order to create this GIC, the
    customer's primary account will need to contain an amount of money greater
    or equal to the principle. Otherwise, the request will fail when the Bank
    Manager attempts to create the GIC.


Time-Dependant Operations
-------------------------
The operations of the savings account, redeemable GIC, and financial products
depend on the bank time. Every time the program is shut down safely (see
"Shutting Down the Program" above), the date of the bank will increment by one
day. On the first day of each month, all time-dependent accounts and financial
products will be updated (e.g., to increment interest).


Withdrawing Cash
----------------
When withdrawing cash from the ATM, the ATM will attempt to find a combination
of bills that satisfies the withdrawal. The program uses an algorithm modelled
on the "knapsack" problem, adapted from https://stackoverflow.com/questions/
22128759/atm-algorithm-of-giving-money-with-limited-amount-of-bank-notes.

An explanation of the algorithm:
We first check if this arrangement of bills is equal to, less than, or greater than the desired dollar amount.
When it's equal, we can simply add it to our growing list of solutions.
When it's greater than our desired amount, we end the whole thing with what we already have, since at that
point, we've exhausted the solutions to this variation.
Starting from an array of all zeroes, we start incrementing on the first bill denomination. In this case,
since we chose to order the bills from largest to least, we will likely get a return which uses the least
number of bills.
As long as the real stock is strictly greater than the stocking variation, we can try to create variations on
our variation.
If those variations work, we add them, too.

If the ATM is low on bills, a message is written to externalFiles/alerts.txt
when a customer attempts to withdraw. A bank employee  can view this alert, and
can later restock the ATM with additional bills.

The default ATM of the program has 0 bills. So, you should restock the ATM
before attempting to make a withdrawal when setting up the program.



#####################
## DESIGN DECISIONS
#####################

A PDF of our UML diagram is available in design.pdf. We omit the inheritance
hierarchy for our Privilege class, as it is large (see "Privileges" below).

Accounts
--------
The top-level Account, as well as its immediate subclasses AssetAccount
and DebtAccount are all abstract. Debt accounts are all those accounts which
display a positive balance when in debt. Asset accounts are all those accounts
which display a negative balance when in debt.

Each account contains a List<String> containing the usernames of the users
which own it. The account can easily be made into a joint account by adding
a new name to this List.

All accounts for the bank are stored in a single instance of the AccountManager
class, which contains a HashMap of type <String, Account>. When each account
is initialized, it is assigned a random UUID which is used as the key in the
AccountManger HashMap. When the AccountManger communicates with the control
structures of the program (see "Privileges" below), it exchanges these UUIDs
to identify each account.

The AccountManger is responsible for facilitating communication with control
structures, and generating transactions (see "Transactions" below). It also
can call the Account.update method for all of its accounts, which causes
end-of-the-month operations to be executed where applicable.

Accounts are initialized using an AccountFactory.


Transactions
------------
Transactions are responsible for executing and reverting transactions, as well
as recording the details of a transaction. The top level Transaction is
abstract, and contains several subclasses for different types of transactions.

Transactions are initialized by the AccountManager, and all possess a
Transaction.execute() method and a Transaction.revert() method to execute and
revert a transaction.

All Accounts contain a List<Transaction>, which is used to record the
transaction history for each account and facilitate reverting transactions.


Finance Products
----------------
The two finance products both inherit from an abstract FinanceProduct class.
All contain an associated Account, a duration, and an investment. Finance
products for the program are held in a ProductManger, which contains a
List<FinanceProduct>. Finance products are initialized with a ProductsFactory.


ATM
---
The ATM class is used to keep track of bills, write to alerts.txt, and calculate
bill withdrawal amounts. It contains an inner class, ATMCalculator, which is
used to calculate possibly bill combinations.


Bank
----
The Bank serves as a container for the various managers (AccountManager,
UserManager, etc.). It's primary purpose is to be serialized to save the
state of the program. We chose to serialize a single large Bank object rather
than serialize each manager separately, because this ensures that the object
reference tree is preserved upon deserialization. Otherwise, it is possible
that certain objects would be duplicated when being deserialized if multiple
references to them exist.


Requests
--------
A Request is an object generated by a Customer and used by the Bank Manager to
perform certain actions. There are three types of requests: AccountRequest,
ProductRequest, and RevertTransactionRequest, which respectively ask the
Bank Manager to create a new account, create a new financial product, and


Users
-----
For phase 2, we decided not to create a User inheritance hierarchy due to the
requirement of having a fusion customer/employee user. Instead, each User class
is now a container for Role objects, which themselves consist of a collection of
Privileges which a User can perform. Thus, we can mix and match roles to quickly
generate new user types.

The User class consists of a username, a password, and a list of Roles. It
contains methods for verifying its password and getting its roles.

Users are contained in a UserManager, which contains a HashMap<String, User>
with keys corresponding to each User's username. It contains simple methods for
checking the existence of a user and adding new users.

Users are generated using a UserFactory, which returns instances of the User
class with a customized list of Roles. New user types can be generated by
adding an appropriate combination of Roles to the UserFactory. The Roles
are instantiated with a RoleFactory.


Roles
-----
A Role is a collection of privileges. In the program, these correspond to a
single menu in the GUI (e.g., the "Make a transaction" menu corresponds to the
TransactionRole). Each role contains a list of Privilege names, as well as
methods for instantiating the appropriate Privileges with a PrivilegeFactory,
and generating a tree corresponding to its privileges (see "OptionsTree" below).

New roles can be created by overriding the Role.setPrivilegeNames() method to
contain appropriate privilege names from the PrivilegeFactory.

All Roles are instantiated with a RoleFactory.


Privilege
---------
A privilege represents an atomic action that a user can take (e.g., change
their password).

All privileges contain a perform() method, which is overridden
for each new privilege to perform the desired action. The perform() method takes
as parameters GUI elements, which it uses to retrieve input from the user and
display messages (see "GUI" below).

Privileges also contain a method to generate an OptionsTree for the purpose of
performing the privilege when the user selects the appropriate button. See
"OptionsTree" below for further details.

All privileges are instantiated using a PrivilegeFactory.


Command
-------
The Command interface is a small functional interface used to execute commands
from an options tree. It contains a single method called execute(), which
takes no parameters. It is implemented in the code in the form of lambda
expressions (see "OptionsTree" below).


OptionsTree
-----------
The OptionsTree is a Tree used to keep track of the program menu state, and
execute commands. Each OptionsTree contains a List<OptionsTree> representing
its own children, as well as Command. Thus, the OptionsTree implements an
example of the Strategy design pattern. In practice, only the Commands of the
leaf nodes of an OptionsTree are executed. Internal nodes are used for menu
navigation.

An OptionsTree has a method for prompting the User to select an option amongst
its children. This is used to navigate the program menu.

OptionsTrees are initialized by Privileges and Roles.


Session
-------
The Session class is used to generate a complete OptionsTree from a User's
list of Roles, as well as to navigate the OptionsTree. A Session has a run()
method which is used to begin the Session, and which loops over the OptionsTree
until the user quits the Session.


GUI
---
The GUI for the program consists of a LoginDialog, a MessageDisplay to
display messages to the user, and a GraphicalInputReader to retrieve input
from the user.

The LoginDialog interacts with a LoginManager to verify user passwords.

The MessageDisplay can display arbitrary strings in a pop-up dialog. It can
display both regular messages and error messages.

The GraphicalInputReader has methods for getting String, double, and int input
from the user. It also has a method for getting a user selection from an
arbitrary list of buttons.


ObjectSerializer
----------------
The ObjectSerializer is a generic class used to serialize and deserialize an
object of a specific type. It is used in the code to save and load the bank
state by serializing and deserializing a Bank object.
